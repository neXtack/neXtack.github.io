(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{500:function(t,e,o){t.exports=o.p+"assets/img/ClassPathXmlApplicationContext.3fadca85.png"},516:function(t,e,o){"use strict";o.r(e);var n=o(6),l=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("在上篇中，学习了容器初始化过程，发现里面各种继承，各种委托，所以这里就整理一下这些出现的接口以及实现类的关系。")]),t._v(" "),n("p",[n("img",{attrs:{src:o(500),alt:"ClassPathXmlApplicationContext UML"}})]),t._v(" "),n("p",[t._v("可以看出"),n("code",[t._v("ClassPathXmlApplicationContext")]),t._v("的几种职能：")]),t._v(" "),n("ol",[n("li",[n("code",[t._v("BeanFactory")])]),t._v(" "),n("li",[n("code",[t._v("ApplicationEventPublisher")])]),t._v(" "),n("li",[n("code",[t._v("ResourceLoader")])]),t._v(" "),n("li",[n("code",[t._v("ResourcePatternResolver")])]),t._v(" "),n("li",[n("code",[t._v("MessageSource")])])]),t._v(" "),n("p",[n("code",[t._v("ClassPathXmlApplicationContext")]),t._v("将这些职能全都委托了出去，而"),n("code",[t._v("ClassPathXmlApplicationContext")]),t._v("，更准确的说，应该是"),n("code",[t._v("ApplicationContext")]),t._v("更专注跟用户进行交互，提供统一的操作API，屏蔽实现细节。")]),t._v(" "),n("p",[t._v("如果用户想要扩展，"),n("code",[t._v("ApplicationContext")]),t._v("的实现过程中，提供了大量的模板方法，供子类去扩展；另外，委托的实现也是可以进行替换的，对某个职能进行扩展改造后，替换委托关系就可以了。")]),t._v(" "),n("p",[t._v("所以，还有"),n("code",[t._v("FileSystemXmlApplicationContext")]),t._v("、"),n("code",[t._v("AnnotationConfigWebApplicationContext")]),t._v("等实现，通过很小的改动就可以实现一个新的容器类型。")])])}),[],!1,null,null,null);e.default=l.exports}}]);